package fr.utbm.ia54.acotsp

/** 
 * 
 */
import io.sarl.core.DefaultContextInteractions
import io.sarl.core.Destroy
import io.sarl.core.Initialize
import io.sarl.core.InnerContextAccess
import io.sarl.core.Lifecycle
import io.sarl.core.Logging
import java.util.ArrayList
import java.util.UUID
import java.util.Random;
import java.util.HashSet

/** 
 * @author Omen
 * 
 */
@SuppressWarnings("potential_field_synchronization_problem")
agent ACOManager {
	uses Logging, InnerContextAccess, DefaultContextInteractions, Lifecycle

	var myUUID = UUID.randomUUID

	var acoParameters : ACOParameters

	var paths : ArrayList<ArrayList<Integer>>

	var pathsLength : ArrayList<Float>

	var currentBestPath : ArrayList<Integer>

	var currentBestPathLength : Float

	var pheromones = new ArrayList<ArrayList<Float>>

	var numberOfIterationsDone : Integer
	
	var numberOfIterationsWithoutChanges : Integer

	var acoAgentsReady : ArrayList<UUID>

	on Initialize {
		info("The agent was started.")
		loggingName = "ACOManager"
	}

	on Destroy {
		info("The agent was stopped.")
	}

	on NewOptimization {
		info("J'ai recu l'ordre d'une nouvelle optim")
		acoParameters = occurrence.acoParameters as ACOParameters
		numberOfIterationsDone = 0
		numberOfIterationsWithoutChanges = 0
		currentBestPathLength = new Float(999999)
		initializePheromones()
		launchACOAgents()
	}

	on IterationFinished {
		synchronized (paths) {
			synchronized (pathsLength) {
				var path = occurrence.path
				var pathLength = occurrence.pathLength
				paths.add(path)
				pathsLength.add(pathLength)
				// var set = new HashSet<Integer>(path);
				// if (set.size() < path.size()) {
				// info('ALERT DUPLICATE ')
				// info('Path vs occurence path : ' + path + occurrence.path)
				// info('Pheromones :' + pheromones)
				// }
				if (paths.size() === acoParameters.numberOfAnts) {
					if (numberOfIterationsWithoutChanges > 25) {
						pheromones = updatePheromonesWithMutation()
					}
					else {
						pheromones = updatePheromones()
						
					}
					// info('Phéromones : ' + pheromones)
					numberOfIterationsDone++
					if (pathsLength.get(pathsLength.indexOf(pathsLength.min())) < currentBestPathLength) {
						currentBestPath = paths.get(pathsLength.indexOf(pathsLength.min()))
						currentBestPathLength = pathsLength.get(pathsLength.indexOf(pathsLength.min()))
						numberOfIterationsWithoutChanges = 0
						info(
							"Itération : " + numberOfIterationsDone + " Meilleur chemin : " + currentBestPathLength +
								' Parcours : ' + currentBestPath.toString)
					}
					else {
						numberOfIterationsWithoutChanges++
					}
					if (numberOfIterationsDone === acoParameters.numberOfIterations) {
						emit(new OptimizationFinished(pheromones, currentBestPath, currentBestPathLength))
						info("Fin d'optimisation  " + "meilleur chemin : " + currentBestPathLength + ' parcours' +
							currentBestPath.toString)
					} else {
						launchIteration()
					}
				}
			}
		}
	}

	on AgentIsReady {
		acoAgentsReady.add(occurrence.source.UUID)
		if (acoAgentsReady.size == acoParameters.numberOfAnts)
			launchIteration()
	}

	def launchACOAgents() {
		acoAgentsReady = new ArrayList<UUID>
		for (var i = 0; i < acoParameters.numberOfAnts; i++) {
			val childID = UUID.randomUUID
			// info("Spawning new ACOAgent" + childID + "on City :" + i)
			var startingCity = (Math.random() * acoParameters.numberOfCities).toInteger
			ACOAgent.spawnInContextWithID(childID, innerContext, myUUID, startingCity, acoParameters)
		}
	}

	def launchIteration() {
		paths = new ArrayList<ArrayList<Integer>>
		pathsLength = new ArrayList<Float>
		for (acoAgent : acoAgentsReady) {
			innerContext.defaultSpace.emit(myUUID, new NewIteration(pheromones))[it.UUID == acoAgent]
		}
	}

	def initializePheromones {
		for (var i = 0; i < acoParameters.numberOfCities; i++) {
			var temp = new ArrayList<Float>
			for (var j = 0; j < acoParameters.numberOfCities; j++) {
				temp.add(1f)
			}
			pheromones.add(temp)
		}
	}

	def updatePheromones() {
		var newPheromones = new ArrayList<ArrayList<Float>>
		for (var i = 0; i < acoParameters.numberOfCities; i++) {
			var temp = new ArrayList<Float>
			for (var j = 0; j < acoParameters.numberOfCities; j++) {
				var newValue = acoParameters.pheromoneEvaporationFactor * pheromones.get(i).get(j) +
					sumOfPheromoneDeltaComputation(i, j)
				temp.add(newValue)
			}
			newPheromones.add(temp)
		}
		return newPheromones
	}

	def updatePheromonesWithMutation() {
		var newPheromones = new ArrayList<ArrayList<Float>>
		var minPheromones = pheromones.get(0).get(0)
		var minPheromonesIndex = new Pair<Integer, Integer>(0, 0)
		var maxPheromones = pheromones.get(0).get(0)
		var maxPheromonesIndex = new Pair<Integer, Integer>(0, 0)
		for (var i = 0; i < acoParameters.numberOfCities; i++) {
			var temp = new ArrayList<Float>
			for (var j = 0; j < acoParameters.numberOfCities; j++) {
				var newValue = acoParameters.pheromoneEvaporationFactor * pheromones.get(i).get(j) +
					sumOfPheromoneDeltaComputation(i, j)
				temp.add(newValue)
				if (newValue < minPheromones) {
					minPheromones = newValue
					minPheromonesIndex = new Pair<Integer, Integer>(i, j)
				}
				else if (newValue > maxPheromones) {
					maxPheromones = newValue
					maxPheromonesIndex = new Pair<Integer, Integer>(i, j)
				}
			}
			newPheromones.add(temp)
		}
		newPheromones.get(minPheromonesIndex.getKey()).set(minPheromonesIndex.getValue(), maxPheromones)
		newPheromones.get(maxPheromonesIndex.getKey()).set(maxPheromonesIndex.getValue(), minPheromones)
		return newPheromones
	}

	def sumOfPheromoneDeltaComputation(i : Integer, j : Integer) : float {
		var sumOfpheromoneDelta = 0f
		synchronized (paths) {
			synchronized (pathsLength) {
				for (var k = 0; k < paths.size(); k++) {
					if (i != j && isEdgeVisited(paths.get(k), i, j)) {
						sumOfpheromoneDelta += 1 / pathsLength.get(k)
					}
				}
			}
		}
		return sumOfpheromoneDelta
	}

	def isEdgeVisited(path : ArrayList<Integer>, i : Integer, j : Integer) : boolean {
		var response = false
		if (path.get(0) == i && path.get(path.size - 1) == j) {
			response = true
		} else if (path.get(0) == j && path.get(path.size - 1) == i) {
			response = true
		} else {
			for (var n = 0; n < path.size - 1; n++) {
				if (path.get(n) == i && path.get(n + 1) == j) {
					response = true
				} else if (path.get(n) == j && path.get(n + 1) == i) {
					response = true
				}
			}
		}
		return response
	}

	def computePathLength(path : ArrayList<Integer>) {
		var length = 0f
		for (var i = 0; i < path.size - 1; i++)
			length = length + acoParameters.distances.get(path.get(i)).get(path.get(i + 1))
		length = length + acoParameters.distances.get(path.get(path.size - 1)).get(path.get(0))
		return length
	}

	def mutation(path : ArrayList<Integer>) {
		var generator = new Random()
		if (generator.nextInt(100 + 1) < 5) {
			var t = path.get(generator.nextInt(path.size))
			var temp = new ArrayList<Integer>
			for (var i = 0; i < acoParameters.numberOfCities; i++) {
				if (acoParameters.attachedCluster.get(i) == acoParameters.attachedCluster.get(t))
					temp.add(i)
			}
			var s = temp.get(generator.nextInt(temp.size))
			// info(t + ' is replace by ' + s + ' in path : ' + path.toString)
			path.set(path.indexOf(t), s)
			// info(' new path : ' + path)
		}
		return path
	}

}
